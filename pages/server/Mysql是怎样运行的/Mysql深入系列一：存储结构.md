# Mysql深入系列一：存储结构

Mysql服务器中负责对表中的数据进行读取和写入工作的部分是存储引擎，而服务器又支持不同的存储引擎，比如InnoDB，MyISAM，MEMORY等。而InnoDB是MySQL默认的存储引擎，也是最常用到的存储引擎，所以我们需要重点学习。

首先，咱们先看下InnoDB引擎在磁盘中的记录存储结构。

## 1.数据行格式

大家都知道，我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存放形式也称为行格式。InnoDB目前常用的有4种不同类型的行格式，分别是compact，redundant，dynamic和compressed。

### Compact行格式

![](https://pic4.zhimg.com/80/v2-439295784a38d93a17f0d7db590644e7_1440w.jpg)

从图中我们可以看出，一条完整的记录可以分为记录的额外信息和记录的真实数据。记录的额外数据主要是为了方便管理和读取数据。

**变长字段长度列表**

变长字段长度列表主要是记录mysql的变长数据类型的长度，比如varchar，varbinary, text, blob等类型。这个很好理解，mysql需要知道这些变长字段的长度，他才能知道需要读取多长的数据。InnoDB在读取记录的变长字段长度列表时会先查看表结构。并不是所有记录都有变长字段长度列表这一部分。

这里比较有意思的是，变长字段占用的字节数在变长字段长度列表中是**逆序存放**。

> 为什么需要逆序存放？

变长字段长度列表中，每个字段最多可以拥有两个字节来表示真实数据占用的字节数，最大能表达65535的长度。比如我们有三个变长字段分别长度是 1、3、4，那他的存储就是 04 03 01。这里因为变长字段长度比较短，所以一个字节就足够表达了。但是 如果该变长字段允许存储的最大字节数超过255字节，并且真实数据占用的字节数超过127字节，则使用2字节来表示真实数据占用的字节数。

> 最大字节数=字符集规则下表达一个字符需要的字节数 *  该字段定义的最大字符数。

当某个字段占用的字节数特别多，InnoDB有可能把该字段的值的一部分数据存放到溢出页中。

char类型字段的长度信息是否需要存储在 变长字段的长度列表 中取决于其所使用的字符集是否为变长字符集。MySQL中char(M)类型的字段表示该字段最多可以存储 **M个字符** 。对于定长字符集(如ascii字符集)而言，compact行格式下存储该字段所占有的空间固定为M x Maxlen个字节。但是对于变长字符集而言情况就大不一样了，例如utf8字符集，其存储M个字符所需的空间为M~3M个字节。在compact行格式下，char类型字段会由于使用变长字符集而导致其所占的字节数(即长度信息)不定，故此时char类型的数据同样也需要在变长字段的长度列表中存储其长度信息。

**NULL值列表**

一条记录中某些列可能存储NULL值，如果把所有NULL值都放到记录的真实数据中存储会很占地方，所以compact格式把记录中值为null的列统一管理到NULL值列表中。

每个允许存储NULL值的列都对应一个二进制位，二进制位按照列的顺序列序排列。同时MySQL规定NULL值列表必须用整数个字节的位表示，如果不足则高位补0。

**记录头信息**

记录头信息主要用于描述记录的一些属性。

![](https://cdn.jsdelivr.net/gh/oubindo/ImageBed@latest//img/ea1713e3b7c944ca9ab94862c4af1ba9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

**记录的隐藏列**

mySQL对于我们所定义的数据表，还会默认的插入一些其他列(字段)，即所谓的 **隐藏列** 。其字段定义说明如下

* **DB_ROW_ID** ：该字段占6个字节，用于标识一条记录。
* **DB_TRX_ID** ：该字段占6个字节，其值为事务ID
* **DB_ROLL_PTR** ：该字段占7个字节，其值为回滚指针

trx_id和roll_ptr都是记录中一定会有的列，但是row_id只有在表中没有定义主键和unique键的时候才会添加，作为主键使用。

### Redundant行格式

Redundant是MySQL 5.0之前使用的格式，现在已经不用了。

![](https://pic2.zhimg.com/80/v2-de40067a916b9c8055f125eb6e012aad_1440w.jpg)

和compact的区别在于：

1. 字段长度偏移列表会将所有列的长度都逆序存储到字段长度偏移列表。
2. 计算列长度的方式不像compact格式那么直观，他是采用两个相邻偏移量的差值来计算各个列值的长度。

### 溢出列

在compact和redundant行格式中，对于占用存储空间非常多的列(varchar, text, blob)，在记录的真实数据处只会存储该列的一部分数据，而把剩余的数据分散存储在几个其他的页中，然后在记录的真实数据处用20字节存储指向这些页的地址。

产生溢出列的临界点：Mysql中规定一个页中至少存放两行记录，由于MySQL每个数据页大小为16k，那么去掉一些杂项后，每条记录大概到8k以后就会成为溢出列，又称为off-page列。

![img](https://img-bc.icode.best/ae11265f134a4bb59c09e1f5420dbdf8.png)

### dynamic行格式和compressed行格式

这两种格式与compact格式很像，只是在处理溢出列的数据时有点分歧：他们不会再记录的真实数据处存储该溢出列真实数据的前768字节，而是把所有真实数据都存储到溢出列中，只在记录的真实数据处存储20字节的指向溢出页的地址。

compressed格式与dynamic区别的一点是，compressed格式会采用压缩算法对页面进行压缩，以节省空间。

## 2.数据页结构

前面我们介绍了数据在磁盘中存储时的数据行格式，现在我们来介绍下数据在内存中的数据页的结构是什么样的。

先看下数据页结构：

![img](https://img2020.cnblogs.com/blog/1496926/202011/1496926-20201126113029931-1621355504.png)

### 记录在页中的存储 User Record

我们存储的记录会按照特定的格式存储到User Records部分。但是一开始是没有User Record部分的，每当插入一条记录时，都会从Free Space部分申请一个记录大小的空间，并将这个空间划分到User Records部分，当Free space被划分完后，这个页就使用完了。此时如果还有新的记录插入，就要去申请新的页了。

大家可以看到，Free Space其实是按照记录的申请时间来做按序分配的，那么就会带来一个问题：如果某条记录被删除了，是否要移动后面所有的记录往前面排？

大家可以想象到，咱们日常的删除操作有多么频繁，如果每次都做这种搬移的工作，磁盘和cpu都会不堪重负的。按照一般的“空间换时间”思想，咱们会想到，能不能就把这些删除的数据冗余在页结构中，不去挪动他，节省这部分资源消耗。因此，InnoDB特意在每条记录的记录头信息中加了个 `delete_mask`标记删除。所有被删除的记录会组成一个删除链表，记录在这个链表中占用的空间称为**可重用空间**。后续有新纪录插入，则覆盖掉被删除的记录占用的存储空间。

让我们拿数据的头信息来一起看，头信息在页结构中的应用。

![img](https://cdn.jsdelivr.net/gh/oubindo/ImageBed@latest//img/ea1713e3b7c944ca9ab94862c4af1ba9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

delete_mask标记记录是否被删除；

heap_no指的是这条记录在User Record区域中的顺序，系统将最前面的两个index 0和1分配给了Infimum记录和Supremum记录。这两条记录单独存在 `Infimum+Supremum Record`区域中。

`next_record`记录的是当前记录的真实数据到下一条记录的真实数据的距离。通过每条记录的next_record组成一条链表。往后走为正，往前走为负。

> next_record只所以指向的是真实数据的位置，而不是记录头的位置，是因为这个位置特别好，向左读就是记录头信息，向右就是真实数据。由于变长字段长度列表是逆序存放的，所以能提高高速缓存的命中率。

### Page Directory 页目录

页目录是为了方便查找页内记录而设计的。制作过程如下：

1. 将所有正常记录（包括infimum和supremum记录，不包括被删除记录）分为几个组
2. 每个组的最后一条记录作为带头大哥，其余记录作为小弟。大哥的 n_ownd 属性表示该组内共有几条记录。
3. 将每个组中最后一条记录在页面中的地址偏移量单独提取出来，按顺序存储到靠近页尾部的地方，也就是page directory。每个地址偏移量称为一个槽。

对于记录条数还有点规定：对于Infimum所在的分组只能有一条记录，Supremum所在的分组只能在1-8条之间，其余分组记录的条数范围只能在4-8之间。因此当一个分组中的记录数等于8时，再插入一条记录，就会将组中的记录分成两个组，其中一个组4条记录，另一个组5条记录。

查找的过程：

- 通过二分法确定该记录所在分组对应的槽，然后找到该槽所在分组中主键值最小的那条记录。
- 通过记录的next_record属性遍历该槽所在的组中的各个记录。

### Page header和File header

page header中存放的是当前页的一些统计数据，只有数据页有，比如槽数量，记录数，重分配链表头等。

file header中是页级的一些数据，所有页都有，存储上下关联页号，页类型等信息。


### Infimum+Supremum记录

Infimum是页结构中的首条记录，Supremum是最后一条记录。他们区别于User Record，独立存储在User Record之前的区域中。**我理解Infimum+Supremum记录主要是为了给查询设定一个明确的上下边界**。比如我需要查询这页的第一条记录，如果我没有Infimum这条记录，那我就需要遍历所有记录，才能查到哪一条是第一条记录。



### File Trailer

File Trailer主要是记录了一些校验和。用于验证磁盘数据传输是否有问题。
