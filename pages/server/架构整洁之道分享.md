本篇文章是我对于《架构整洁之道》这本书的读书分享，我会将这本书的核心思想和观点提炼出来，因个人水平有限，有疏漏错误之处欢迎指出讨论。

> 本书作者Robert C. Martin，骨灰级程序员，世界级编程大师，另著有《敏捷软件开发：原则、模式与实践》，《代码整洁之道》等书，被尊称Bob大叔。

## 一.架构设计

### 什么是架构设计

大家回头想想，是否有过这样的经历：某个系统因为逻辑错综复杂，相互耦合紧密，核心业务逻辑散布而无法收拢，组件之间边界不清晰，而导致不管多么小的业务改动都需要较高的开发成本，且非常容易导致系统故障，开发与测试人员都苦不堪言。

我相信大部分开发同学都有过这样的经历，在这种时候，我们都会口喷莲花，喷这个系统的“ **设计** ”不好，或者喷代码“ **架构** ”不合理。那么什么是 **设计** ？什么是 **架构** ？两者有区别吗？

在我们的通常观念中，“ **架构** ”这个词往往用于高层级的讨论中，而“ **设计** ”一词则往往用于指代具体的系统底层组织结构和细节。但Bob大叔认为两者没有任何区别，就像新房子的建筑设计图纸一样，我们可以看到房屋形状、外观设计、房间布局等高层次的设计，又能看到诸如插座、开关、电灯等设计细节。所有的底层设计细节共同支撑了顶层的架构设计，底层设计细节与顶层架构设计共同组成了房屋的架构文档。

软件设计也一样，底层设计细节与高层架构信息不可分割，他们组合在一起共同定义软件系统，并且所谓的底层与高层其实是 **一系列决策组成的连续体** ，并没有清晰的边界。而所有这些决策的目标只有一个。

> 软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。

因此软件的架构设计就是我们所选择的构建和维护系统的方式，而评价优劣的标准，就是看用它来满足用户需求的成本。

### 软件系统的价值

而对于每个软件系统，我们都可以通过行为和架构两个维度来体现他的实际价值。

* **行为价值：** 系统的正常运转给使用者创造的价值 **。** 
* **架构价值：** 软件（software）的架构价值体现在“soft”这个词上，软件系统要足够软，也就是要易于被修改来不断满足使用方的需求。例如咱们的系统要不断的迭代需求，支持新功能。

那么对于软件系统来说，这两个价值哪个更重要？行为价值是软件的核心价值，支撑业务是我们工程师的首要责任。如果业务是明确的、稳定的，架构价值就相对没那么重要。但是业务通常是不明确的，高速发展的，这个时候架构价值将无比重要，因为他决定了业务能跑的多快，多稳。

艾森豪威尔曾将所有的事情分为四类，优先级顺序是这样的：重要且紧急的 > 重要不紧急 > 不重要但紧急 > 不重要且不紧急。实现行为价值的需求通常是业务部门提出的，都比较紧急，但并不都是特别重要的，而实现架构价值的需求通常是开发同学提出的，都很重要但不是很紧急。

因此，咱们研发同学需要与业务部门的同学一起来平衡系统架构的重要性与功能的紧急程度，将 重要且紧急 的需求与 不重要但紧急 的需求拆开，将咱们 重要不紧急 的架构需求插入到合适的实现优先级上。

**暂时无法在飞书文档外展示此内容**

## 二.设计原则

设计原则就是架构设计的指导思想，它指导我们如何将数据与函数组织成类，如何将类链接起来成为组件和程序。反过来说，架构的主要工作就是将软件拆解为组件，设计原则指导我们如何拆解、拆解的粒度、组件间依赖的方向、组件解耦的方式等。

设计原则有很多，Bob大叔主要讲了两种类型的原则，一是用于进行模块级编程，致力于帮助我们定义组件和模块的SOLID原则，二是更高级的组件构建原则。我们接下来会分别阐述。

### SOLID原则

SOLID原则事实上是由五种不同的设计原则组成的，分别是：

* SRP（Single Responsibility Principle）：单一职责原则
* OCP（Open Close Principle）：开闭原则
* LSP（Liskov Substitution principle）：里式替换原则
* ISP（Interface Segregation Principle）： 接口隔离原则
* DIP（Dependence Inversion Principle）：依赖反转原则

#### SRP单一职责原则

SRP是SOLID原则中最容易被误解的一个，大家会根据他的名字想当然的认为这个原则就是指：每个模块都应该只做一件事。

当然，这个解释属于SRP面向底层实现细节的一个方面。更准确的描述应该是， **任何一个模块都有且仅有一个被修改的原因** 。如果引入用户和使用者的影响，那SRP的描述应该是， **任何一个模块都应该只对某一类行为者负责。** 当一个模块有多个所有者时，就会产生冲突。例如类A同时服务于职责A和职责B，当他修改职责A的代码时，就可能对职责B造成影响。

单一职责适用于接口、类，同时也适用于方法。例如我们需要修改用户密码，有两种方式可以实现，一种是用「修改用户信息接口」实现修改密码，一种是新起一个接口来实现修改密码功能。在单一职责原则的指导下，一个方法只承担一个职能，所以我们应该新起一个接口来实现修改密码的功能。

#### **OCP****开闭原则**

开闭原则的含义是： **设计良好的计算机软件应该易于扩展，同时抗拒修改** 。换句话说，一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展。

这个原则也是服务于我们前面讲到的架构设计目标的，如果对现有需求的小小延伸就需要对原有的软件系统进行大幅修改，那这个系统的的架构设计显然是失败的。

以一个水果剥皮程序为例。

```Plain
if(type == apple){ 
    // 苹果剥皮
} else if (type == banana){ 
    // 香蕉剥皮
} else if (type == ......){ 
    //...... 
}
```

每新加一种水果都需要在这个程序中修改他的主流程，增加一种新的剥皮方式，这无疑增加了系统风险。但是如果我们改成这样

```Bash
public interface PeelOff { 
    void peelOff(); 
} 
 
public class ApplePeelOff implement PeelOff{ 
    void peelOff(){ 
      //苹果剥皮
    } 
} 
 
public class BananaPeelOff implement PeelOff{ 
    void peelOff(){ 
      //香蕉剥皮
    } 
} 
 
public class PeelOffFactory{ 
    private Map<String, PeelOff> map = new HashMap(); 
 
    private init(){ 
      //初始化所有的剥皮方式
   } 
}
```

每次要新增一种水果，只需要实现它的剥皮能力即可对系统现有的能力进行扩展。这样我们既保护了主流程不被修改，也能降低扩展的成本。

#### LSP里式替换原则

里式替换原则的含义是， **一个对象在其出现的所有地方，都可以用子类实例做替换，并且不会导致程序的错误** 。这个原则其实隐藏的含义是，父类作为约定在其出现的所有场景生效。这里的约定不仅是语法层面上的约定，也包括实现上的约定。例如父类中的方法是约定按照从大到小做排序，子类就不能实现为从小到大做排序。

#### ISP接口隔离原则

接口隔离原则的含义是，类间的依赖关系应该建立在最小的接口上。在软件设计中，接口隔离原则提倡不要把一个大而全的接口扔给使用者，而是将每个使用者关注的接口进行隔离。

**暂时无法在飞书文档外展示此内容**

通过接口进行隔离会带来一定的好处：

* 降低了改动风险，ops对于每个接口的改动只会影响这个接口的依赖方，未依赖这个接口的使用方无需关注。
* 对于静态类型语言而言，隔离了依赖关系后能避免不必要的重新编译和部署。

#### DIP依赖反转原则

OCP开闭原则被认为是我们整个设计的终极目标，而DIP原则则是实现OCP原则的基础方法。

依赖反转原则的含义是，高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。它主要想告诉我们，如果要设计一个灵活的系统，在源代码层次的依赖关系上就应该多引用抽象类型而非具体实现。

在大部分面向对象编程语言中，人们都会选择使用抽象工厂模式来解决这个依赖问题。例如下图。

**暂时无法在飞书文档外展示此内容**

图中的依赖边界代表的是软件架构中的抽象层与具体实现层的边界，所有跨过这条边界的依赖关系都应该是单向的，即具体实现层依赖抽象层。

### 组件构建原则

大型软件系统的构建过程与建筑物构建过程相似，都是由一个个小组件组成的。如果说SOLID原则是用于指导我们如何设计类及方法，那么组件构建原则就是用来指导我们如何将这些类及方法组合成组件的。

主要涉及几个方面：

* 什么类应该被聚合为一个组件？什么不应该聚合进来？
* 组件之间应该是什么依赖关系？

#### 组件聚合

Bob大叔介绍了组件聚合的几个基本原则：

* REP（The Reuse/Release Equivalence Principle）：复用/发布等同原则
* CCP（The Common Closure Principle）：共同闭包原则
* CRP（The Common Reuse Principle）：共同复用原则

##### REP复用/发布等同原则

复用/发布等同原则的含义是，软件复用的最小粒度应该等同于其发布的最小粒度。也就是说，一个组件不能由一堆毫无关联的类和模块组成，他们之间应该有一个共同的主题或大方向，并且这堆代码是可以独立发布的。

Bob大叔强调了组件发布应该使用包管理系统（例如maven，npm等）来跟踪和管理，并且要遵循一个流程去通知组件新版本的发布和修改。但是我认为包管理并不是发布的必备条件。组件中的代码只要足够内聚，就可以作为一个独立单元进行发布，而并不一定要用包管理系统进行管理。这时候的复用也是合理的。

##### CCP共同闭包原则

共同闭包原则的含义是，我们应该将那些会被同时修改，并且为相同目的而修改的类放到同一个组件中，而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。

这其实是SRP原则在组件层面的再度阐述。设想如果我们不将这些组件放在一起，我们就需要同时修改多个组件，软件发布、验证及部署带来的压力，以及变更的风险都会很高。遵循CCP原则，组件的可维护性会更高。

##### CRP共同复用原则

共同复用原则的含义是，不要强迫一个组件的用户去依赖他们不需要的东西。也就是说，一个组件里的所有类和模块都应该是为实现相同目的而关联在一起的，如果某个类与组件的功能无关，他就不应该存在于这个组件中。

为什么这个原则有意义呢？因为依赖方如果依赖了不需要的类，就会因为这些类的变更而重新编译，验证和部署。而这是无意义的。

CRP原则实际上是ISP原则的一个普适版。ISP原则是建议我们不要依赖带有不需要的函数的类，而CRP原则则是建议我们不要依赖带有不需要的类的组件。

##### 组件聚合张力图

上面三个原则之间彼此存在着竞争关系。REP和CCP是聚合性原则，会使组件变得更大，而CRP是排除性原则，会使得组件变小。

**暂时无法在飞书文档外展示此内容**

我们在做架构设计的时候，要在这三个原则中进行取舍。一般软件项目早期主要牺牲的是复用性，随着项目逐渐成熟，项目重心会逐渐向三角的左侧滑动。

#### 组件依赖

##### ADP无依赖环原则

当我们根据上面的三条组件聚合原则构建出我们的组件之后，我们就需要考虑，多个组件之间应该是什么关系，他们之间的依赖是否合理。

首先， **组件依赖关系图中不应该出现环** 。这个道理很简单，假设A依赖B，B依赖C，C又依赖A。那么C修改以后，B需要根据C的修改去修改，A需要根据B的修改去修改，C又需要根据A的修改去修改，然后出现了死循环，项目将会难以稳定发布。

为了消除循环依赖，我们会将研发项目划分为一些可单独发布的组件，然后控制好组件之间的依赖关系，绝对不允许出现循环依赖。

那么，有什么办法可以用于打破循环依赖呢？假设我们现在要打破下图Entities对于Authorizer的依赖。

* 使用DIP依赖反转原则。

**暂时无法在飞书文档外展示此内容**

* 创建一个新的组件。将需要依赖的组件抽出来单独作为一个新组件，当然这个方法会导致系统中的组件数量变化，需要想好再行动。

**暂时无法在飞书文档外展示此内容**

##### SDP稳定依赖原则

软件架构的一个重要目标就是隔离频繁的变更。我们不希望频繁变更，不稳定的组件影响到其他本来应该很稳定的组件。

如何量化一个组件的稳定性，一种办法是计算所有入和出的依赖关系。

* Fan-in：入向依赖，指代组件外部类依赖于组件内部类的数量。
* Fan-out：出向依赖，指代组件内部类依赖组件外部类的数量。
* I：不稳定性，I=Fan-out/(Fan-in+Fan-out)。

I=0代表组件最稳定，这时候当前组件是其他组件所依赖的对象，其他组件对他的依赖关系会导致这个组件难以被变更。且由于自身不依赖任何组件，也没有来自外部的变更原因。（这里要注意，稳定不代表这个系统很少迭代，而是说上游对他的依赖过多，导致他必须对外稳定。而内部怎么变更都可以）

I=1代表组件最不稳定。这时候当前组件没有被别的组件依赖，所以自身的变更也没有办法被干预。同时因为自己依赖于其他组件，所以经常需要变更。

稳定依赖原则要求我们， **组件依赖图中各组件的I指标必须按其依赖关系方向递减** 。

##### SAP稳定抽象原则

稳定抽象原则的含义是， **一个组件的抽象化程度应该与其稳定性保持一致** 。

前面我们讲到了，稳定组件相对变更会更少，但是同时他也得支持修改，不然我们想修改这些组件中的逻辑就会非常痛苦。我们可以使用OCP开闭原则，依赖抽象类（包括接口）来构建易于变更的系统。

我们以抽象类在组件中的占比来形容一个组件的抽象程度。稳定抽象原则要求稳定的组件同时应该是抽象的，这样它的稳定性就不会影响到扩展性。这些既稳定又便于扩展的组件就可以被组合成灵活又不会受到过度限制的架构。

##### 小结

通过三原则我们可以了解到，我们组件之间依赖关系应该是一个有向无环图，并且组件应该要按照I指标递减的方向去进行依赖。稳定的组件需要提升自己的抽象程度来满足易于变更的需求。

## 三.软件架构

通过前面的设计原则一节，我们已经掌握了屠龙之术。而软件架构的实质就是利用我们的屠龙之术规划如何将系统切分成组件，并安排好组件之间的依赖关系及通信方式。

一个好的软件架构，能支撑软件系统的全生命周期，包括开发、测试、部署、运行、维护。可以使得系统便于理解，易于修改与维护，并且能最大化程序员的生产力，最小化系统的总运营成本。

### 整洁架构

过去几十年里，曾经有一系列关于系统架构的想法，例如BCE架构，DCI架构等，这些架构虽然细节不同，但是都有同一个设计目标：按照不同关注点对软件进行切割。他们都会将软件切割成不同的层，至少有一层是只包含软件的业务逻辑，而用户接口，框架等则属于其它层。

按照这些架构设计出来的系统，通常都有以下特点：

* 独立于框架：这些系统架构并不依赖于某个功能丰富的框架。框架只会被当做工具。
* 独立于UI：可以在不修改业务逻辑的前提下修改UI。
* 独立于数据库：可以轻松将数据库进行替换。
* 独立于任何外部接口：不需要知道任何外部接口的存在。
* 可被测试：业务逻辑可以脱离UI、数据库等元素来进行测试。

Bob大叔的整洁架构设计理念也基本一致，示意图如下

![](https://cdn.jsdelivr.net/gh/oubindo/ImageBed@latest//img/20221127231258.png)

图中的同心圆代表了软件系统中的不同层次，越靠近中心软件层次就越高。低层是实现机制，内层圆是策略。依赖关系只能从低层实现指向高层策略。也就是说：内层圆中的代码不应该引用外层圆的代码（例如外层圆声明的类，使用的数据格式等）。

从内至外每一层分别是：

1. **业务实体**

业务实体这一层中封装的是整个系统的关键业务逻辑，一个业务实体既可以是一个带有方法的对象，也可以是一组数据结构和函数的集合。

业务实体中封装了应用中最通用、最高层的业务逻辑。他们应该是系统中最不容易受外界影响而变动的部分。

2. **用例**

软件的用例层中通常包含的是特定应用场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。这些用例引导了数据在业务实体之间的流入/流出，并指挥着业务实体利用其中的关键业务逻辑来实现用例的设计目标。

我们希望这一层中的变更能跟业务实体，以及外部因素（例如数据库、UI等）进行隔离，互不影响。但是，应用行为的变化也会影响用例本身，这时候的代码变更是合理的。

3. **接口适配器**

软件的接口适配器层中通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便操作的格式，与外部系统（譬如数据库以及Web）最方便操作的格式进行相互转化。

4. **框架与外部设备**

最外层一般由UI、数据库、框架等组成，这一层中包含了所有的实现细节。我们将这些实现细节放到最外层，这样他们就很难影响到其它层了。

通过上面的分层设计，我们能确保这些组件遵守依赖关系规则，这样就可以构建出一个灵活，便于测试，稳定且易于修改的系统。
